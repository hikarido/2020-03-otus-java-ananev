/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package hw08.mygson;

import javax.json.*;
import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.util.Collection;


/**
 *
 * <p>Utility class provides toJson method</p>
 *
 * <p><b>Usage sample</b></p>
 *
 * 1) Declare the class with couple fields
 * <blockquote><pre>
 * public class A {
 *     private int INT = 3;
 *     private int[] INTS = {1,2,3,4,5,6};
 *
 *     private String STR = "str";
 *     private String[] STRS = {"str0", "str1"};
 *
 *     private int defaultInt;
 *     private String defaultString;
 *     private Object defaultReference;
 *
 *     private Collection collection = new ArrayList(Arrays.asList(1,2,3,4,5,6));
 *     private int[][] nestedArray = new int[][]{{1,2,3}, {1,2,3}};
 *
 *     private char aChar = 'a';
 *     private byte aByte = 0x1;
 *     private long aLong = 123L;
 *     private short aShort = 10000;
 *     private boolean aBoolean = false;
 *     private float aFloat = 1.24F;
 *     private double aDouble = 1.23;
 * }
 *
 * # 2) serialize it
 * String jsonRepresentation = MyGson.toJson(new A())
 *
 * # 3) See output is:
 * {
 *     "aBoolean": false,
 *     "aByte": 1,
 *     "aChar": "a",
 *     "aDouble": 1.23,
 *     "aFloat": 1.24,
 *     "aLong": 123,
 *     "aShort": 10000,
 *     "collection": [
 *         1,
 *         2,
 *         3,
 *         4,
 *         5,
 *         6
 *     ],
 *     "defaultInt": 0,
 *     "defaultReference": null,
 *     "defaultString": null,
 *     "INT": 3,
 *     "INTS": [
 *         1,
 *         2,
 *         3,
 *         4,
 *         5,
 *         6
 *     ],
 *     "nestedArray": [
 *         [
 *             1,
 *             2,
 *             3
 *         ],
 *         [
 *             1,
 *             2,
 *             3
 *         ]
 *     ],
 *     "STR": "str",
 *     "STRS": [
 *         "str0",
 *         "str1"
 *     ]
 * }
 * </pre>
 * </blockquote>
 *
 * <p><b>Supports</b></p>
 * <p>* Primitives</p>
 * <p>* Float</p>
 * <p>* Double autoboxing</p>
 * <p>* java.util.Collection</p>
 * <p>* arrays and nested arrays of previous types</p>
 * <p>* Nested object declaration</p>
 * <p></p>
 *
 * <p><b>Nested object declaration</b></p>
 * You can declare custom class in Class declaration and it will be serialized.
 * Look at sample:
 * <blockquote><pre>
 * class B{
 *     int a = 3;
 * }
 *
 * public class A {
 *     private int INT = 3;
 *     private B b = new B();
 * }
 * # serialize it
 * String jsonRepresentation = MyGson.toJson(new A())
 *
 * # result
 * {
 *     "INT": 3,
 *     "b": {
 *        "a": 3
 *     }
 * }
 *</pre></blockquote>
 * <p><b>About logic of String, Integer and so on</b></p>
 *
 * <p>Google Gson yields Gson.toJson("hello") -> "hello"</p>
 * <p>MyGson yields MyGson.toJson("hello") ->
 * "{long json with all inner String fields: value, coder, hash, serialVersionUID....}.</p>
 *
 * <p></p>
 * <b>I have learned you all what I know</b>
 */
public class MyGson {

    public static String toJson(Object instance) {
        if(instance == null){
            return JsonValue.EMPTY_JSON_OBJECT.toString();
        }

        try{
            JsonValue value = toJsonObject(instance, instance.getClass());
            return value.toString();
        }
        catch (IllegalAccessException e){
            throw new RuntimeException("Cant serialize to json", e);
        }
    }

    private static JsonValue iterateNext(Object value, Class<?> type) throws IllegalAccessException {
        if(value == null){
            return JsonValue.NULL;
        }
        else if(type.isArray()){
            return toJsonArray(value);
        }
        else if(type.isPrimitive()){
           return toJsonPrimitive(value, type);
        }
        else if(Collection.class.isAssignableFrom(type)){
            Collection collection = (Collection)value;
            return toJsonArray(collection.toArray());
        }
        else if(type.equals(String.class)){
            return Json.createValue((String)value);
        }
        else if(Number.class.isAssignableFrom(type)){
            return toJsonAutoBoxClasses(value, type);
        }
        else {
            return toJsonObject(value, type);
        }
    }

    private static JsonValue toJsonArray(Object value) throws IllegalAccessException {
        JsonArrayBuilder arrayBuilder = Json.createArrayBuilder();
        if(value == null){
            return JsonValue.NULL;
        }

        int len = Array.getLength(value);

        if(len == 0){
            return JsonValue.EMPTY_JSON_ARRAY;
        }

        for(int i = 0; i < len; i++){
            Object val = Array.get(value, i);
            Class<?> type = val.getClass();
            arrayBuilder.add(iterateNext(val, type));
        }

        return arrayBuilder.build();
    }

    private static JsonValue toJsonPrimitive(Object value, Class<?> type){
        if(type.equals(int.class)){
            return Json.createValue((int)value);
        }
        if(type.equals(long.class)){
            return Json.createValue((long)value);
        }
        if(type.equals(char.class)){
            // required by Gson. It cant in char as int like 97 <=> 'a'
            return Json.createValue(value.toString());
        }
        if(type.equals(float.class)){
            return handleFloatPrimitive(value);
        }
        if(type.equals(double.class)){
            return Json.createValue((double)value);
        }
        if(type.equals(boolean.class)){
            return (boolean)value == true ? JsonValue.TRUE: JsonValue.FALSE;
        }
        if(type.equals(short.class)){
            return Json.createValue((short)value);
        }
        if(type.equals(byte.class)){
            return Json.createValue((byte)value);
        }

        throw new RuntimeException("All primitive types was covered. Cant handle type: " + type);
    }

    /**
     * float obstacles of float to double conversation
     * value = 1.24F but in double it represents as 1.2400000093243
     * we make value = 1.24D
     * @param value
     * @return
     */
    private static JsonValue handleFloatPrimitive(Object value) {
        String s = value.toString();
        return Json.createValue(Double.parseDouble(s));
    }

    private static JsonValue toJsonAutoBoxClasses(Object instance, Class<?> type){
        boolean toLong =
                Integer.class.isAssignableFrom(type) ||
                        Byte.class.isAssignableFrom(type) ||
                        Long.class.isAssignableFrom(type) ||
                        Short.class.isAssignableFrom(type);

        boolean toDouble =
                Float.class.isAssignableFrom(type) ||
                Double.class.isAssignableFrom(type);

        if(toLong){
            Long val = Long.valueOf(instance.toString());
            return Json.createValue(val.longValue());
        }

        if(toDouble){
            Double val = Double.valueOf(instance.toString());
            return Json.createValue(val.doubleValue());
        }

        throw new RuntimeException("AutoBox type is not supported: " + type);
    }

    private static JsonValue toJsonObject(Object instance, Class<?> instanceType) throws IllegalAccessException {
        JsonObjectBuilder builder = Json.createObjectBuilder();
        if (instance == null) {
            return JsonValue.NULL;
        }

        Field[] fields = instanceType.getDeclaredFields();

        for (Field fieldDescriptor : fields) {
            fieldDescriptor.setAccessible(true);
            String name = fieldDescriptor.getName();
            Object value = fieldDescriptor.get(instance);
            Class<?> type = fieldDescriptor.getType();
            JsonValue nextJsonValue = iterateNext(value, type);
            builder.add(name, nextJsonValue);
        }

        return builder.build();
    }
}